.help sys_runtask
.nf __________________________________________________________________________
SYS_RUNTASK -- Called by the IRAF Main to run one of the tasks in a
process.  This file is the template for the actual procedure, which
is generated by the compiler in processing the TASK statement.

The special statements TN$DECL and TN$DICT are replaced, respectively, by
the code to declare the task name strings, and the code to search the
dictionary and execute a task.  The dictionary consists of the string buffer
DICT, containing the EOS delimited task name strings, and a array DP
containing the indices of the individual strings.
.endhelp ______________________________________________________________________

int procedure sys_runtask (task, cmd, arglist_offset, interactive)

char	task[ARB]		# task name
char	cmd[ARB]		# command line
int	arglist_offset		# offset of argument list in CMD
int	interactive		# we were called interactively

int	i, ntasks
int	lmarg, rmarg, maxch, ncol, ea_warn
bool	streq()
int	envgeti(), envscan()
TN$DECL	# task name declarations (DP, DICT)
data	ntasks /0/
data	lmarg /5/, maxch /0/, ncol /0/, ea_warn /3/

begin
	# Upon the first entry, count the number of tasks (the DP array
	# containing the indices of the strings is NULL delimited).

	if (ntasks == 0) {
	    for (i=1;  dp[i] != NULL;  i=i+1)
		;
	    ntasks = i - 1
	}

	# Search the dictionary for the named task and execute it.  The
	# special builtin task "?" prints the contents of the dictionary.
	# CHDIR changes the working directory; SET adds set declarations
	# to the environment list.  If a SET or CHDIR cannot be processed
	# for some reason when we are run as a connected subprocess (i.e.,
	# noninteractively), it is a fatal error.  This is done because
	# STDERR is redirected into the nullfile during process startup,
	# hence any warning messages would not be seen by the parent.

	if (task[1] == '?') {					# ?
	    # Print a menu listing all available tasks.
	    iferr (rmarg = envgeti ("ttyncols"))
		rmarg = 80
	    call strtbl (STDOUT, dict, dp, ntasks, lmarg, rmarg, maxch, ncol)
	    return (OK)

	} else if (streq (task, "chdir")) {			# CHDIR
	    # Change the working directory.
	    iferr {
		if (cmd[arglist_offset] == EOS)
		    call fchdir ("home$")
		else
		    call fchdir (cmd[arglist_offset])
	    } then if (interactive == YES) {
		call erract (ea_warn)
	    } else
		; # call sys_panic (0, "invalid CHDIR in IRAF Main")
	    return (OK)

	} else if (streq (task, "set")) {			# SET
	    # Set the value of an environment variable.  If called
	    # with no args print the current environment list.
	    iferr {
		if (cmd[arglist_offset] == EOS) {
		    call envlist (STDOUT, "\t", YES)
		    call flush (STDOUT)
		} else if (envscan (cmd) <= 0) {
		    if (interactive == YES) {
			call eprintf ("invalid set statement: '%s'\n")
			    call pargstr (cmd)
		    } else
			goto 91
		}
	    } then if (interactive == YES) {
		call erract (ea_warn)
	    } else
 91		call sys_panic (0, "invalid SET in IRAF Main")
	    return (OK)
	}

	# The following symbol is expanded into the interpreter code for
	# the dictionary of user tasks.

	TN$INTERP

	# If we get here the named task could not be found.
	return (ERR)
end
