.help imcalc Jan85 "Prototype Image Calculator"
.ce
\fBDesign of the Prototype Image Calculator\fR
.ce
Doug Tody
.ce
January, 1985
.sp 3
.nh
Introduction

    The prototype image calculator shall provide the basic functionality of
the image calculator without trying to solve the harder problems, e.g.,
very large image lines, built in transpose capability, user supplied functions,
bad pixels, consolidation of image headers, option to operate in world
coordinates, and so on.  Even if only the most basic capabilities are provided,
the image calculator should be quite a powerful tool.

.nh
Input Language

    Input to the image calulator consists of a sequence of one or more
algebraic statements to be parsed and executed by the calculator.  Initially
only one type of statment will be supported, the assignment statement.
The left hand side may be either the name of a new image to be written,
or a section of an existing image.  The right hand side may be any arithmetic
or boolean expression involving images or image sections, numeric constants,
or function calls.  The usual arithmetic and boolean operators are provided,
plus the conditional expression operator '?', used to express operations that
are conditional upon the value of individual pixels.

.nh 2
Lexical Form

.tp 4
.nf
general:

	EQUALS		=		assignment operator
	SEMICOLON	;		statement delimiter
	NEWLINE		'\n'		line or statement delimiter
	CONSTANT	44, 33.2E4	int, real, complex, sexagesimal
	IDENTIFIER	m74, m74[*,*]	image or image section

arithmetic operators:

	PLUS		+		binary addition
	MINUS		-		binary subtraction, unary negation
	STAR		*		binary multiplication
	SLASH		/		binary division
	EXPON		**		binary exponentiation

boolean operators:

	LT		<		less than
	GT		>		greater than
	LE		<=		less than or equals
	GE		>=		greater than or equals
	EQ		==		equal		
	NE		!=		not equal
	AND		&&		boolean and
	OR		||		boolean or

conditional operators:

	QUEST		?		begin a conditional expression
	COLON		:		else clause of conditional expr
.fi

.nh 2
Syntax


.tp 3
.nf
	command	:	assign eost
		;

	assign	:	image EQUALS opnl expr
		;

	eost	:	SEMICOLON
		|	NEWLINE
		;

	expr	:	image
		|	CONSTANT
		|	MINUS expr %prec UMINUS
		|	NOT expr
		|	expr PLUS opnl expr
		|	expr MINUS opnl expr
		| 	expr STAR opnl expr
		|	expr SLASH opnl expr
		|	expr EXPON opnl expr
		|	expr LT opnl expr
		|	expr GT opnl expr
		|	expr LE opnl expr
		|	expr GE opnl expr
		|	expr EQ opnl expr
		|	expr NE opnl expr
		|	expr AND opnl expr
		|	expr OR opnl expr
		|	expr QUEST opnl expr COLON opnl expr
		|	IDENTIFIER '(' arglist ')'
		|	'(' expr ')'
		;

	arglist	:	# Empty.
		|	expr
		|	arglist ',' expr
		;

	image	:	IDENTIFIER
		;

	opnl	:	# Empty.
		|	opnl NEWLINE
		;
.fi

.nh 2
Intrinsic Functions

    A range of conventional Fortran style instrinsic functions are provided,
usable for either scalars or vectors.  These functions take a scalar or vector
as input and return a scalar or vector result.  All functions are generic.
Input to the trigonometric functions is in radians.  The \fIatan\fR function
accepts either one or two arguments.  The \fImin\fR and \fImax\fR functions
accept any number of arguments; scalar and vector arguments may be mixed in
the same call.


.ks
.nf
	acos     atan     conjg    exp      log10    mod      sin      
	aimag    bool     cos      int      max      nint     sqrt     
	asin     complex  double   log      min      real     tan      
.fi
.ke


In addition, a number of special projection functions are provided.
If called with a single vector argument these functions return a
scalar result computed by projection along the vector.  If called with
N vector arguments (N > 1), the functions return a vector result computed
by projection across the N vectors.  The exception is the \fIlen\fR
function, which when called with N vector arguments returns a vector
of length N containing the length of each input vector.


.ks
.nf
	avg		mean or average of a vector
	med		median value of a vector
	low		lowest value in a vector
	high		highest value in a vector
	sum		sum of the elements of a vector
	len		length of a vector
.fi
.ke


In the context used above, a vector argument is an image or image section.
The function will be called once for each \fIline\fR in the image or image
section.

.nh
Principles of Operation

    The image calculator operates by compiling and executing input statements
entered as a string in the argument list or read from a file or the standard
input.  Each input statement is compiled into a sequence of virtual machine
instructions, producing a program segment as output.  If compilation is
successful the program segment is executed.  Each input statement is compiled
as a loop over the lines in the output image; the body of the loop is
executed once for each line written to the output image or image section.

If end of file is reached on an input image before the output section is
filled, the last line read from the input image is reused in subsequent
iterations, hence vectors and images may be mixed in the same expression
(e.g., an image may be multiplied by a vector).  All i/o is line sequential,
hence there are no restrictions on the dimensionality of an image, other than
the builtin limit of seven dimensions per image.  Upon program termination or
error abort all images are closed and all storage is freed.  Any number of
statements may be compiled and executed in sequence.

    The image calculator program consists of two main parts: the compiler and
the virtual machine which executes the compiled virtual machine instructions.

.nh 2
Architecture

    The internal virtual machine is analogous to a conventional sequential cpu
in that it provides a finite number of registers and a well defined instruction
set with instructions for i/o, arithmetic computation, order comparisons,
and branching.  The principal difference is that the instructions and registers
operate upon vectors as well as scalars.  All instructions and registers may be
used for operands of any of the datatypes \fBbool\fR, \fBshort\fR, \fBint\fR,
\fBlong\fR, \fBreal\fR, \fBdouble\fR, or \fBcomplex\fR, with automatic type
coercion in mixed mode expressions.  The boolean datatype is implemented as
integer internally.

.nh 3
Registers

    The internal architecture of the image calculator uses registers rather
than an RPN stack to avoid allocating and deallocating storage for vector
operands on the stack during execution.  Vector storage is assigned to each
register once during compilation, and freed at program termination.
No attempt is currently made to minimize storage requirements by reusing
registers.  A maximum of 100 registers are currently provided; the limit on
the number of available registers determines the maximum complexity of the
expression to be evaluated.  Each register has the following structure:


.ks
.nf
	struct register {
		int	r_datatype	# operand datatype
		int	r_length	# vector length
		union {
		pointer	v_p		# pointer value
		short	v_s		# short constant
		int	v_i		# integer constant
		real	v_r		# real constant
		double	v_d		# double constant
		complex	v_x		# complex constant
		} r_val
	}
.fi
.ke


The datatype and length of a register are determined at compile time;
storage is also allocated from the heap if the register is to hold a vector.
If the register contains a scalar the vector length is one.  The register
allocator is extremely simple, merely allocating the next available register
in the array of 100 registers.  Registers are freed by deallocating any
associated storage and setting the vector length field to zero.  Compile time
constant expressions involving either scalars or vectors (e.g., the projection
of a vector constant) are evaluated at compile time, appearing in the final
compiled program as a register constant.

.nh 3
Instructions

    The virtual machine instructions may have up to four operands.
For simplicity, each instruction occupies the same amount of space in a
compiled program segment.  All operands are of type integer, e.g.,
the image descriptor index or register number.  There are no instructions
for loading scalars into registers since this can be done at compile time
by the parser.  The boolean instructions test for zero (false) or nonzero
(true) upon input, and produce zero (false) or one (true) upon output.

.ls
.ls LOAD source.im, dest.reg
Load the next line from the input image into the output register.
.le
.ls STORE source.reg, dest.im
Store the contents of the input register in the next line of the output
image.  If the register holds a scalar, a constant vector is output.
.le
.ls BNEOF address
Branch to the instruction address given if EOF has not yet been reached on
the output image.
.le
.ls SELECT sel.reg, true.reg, false.reg, dest.reg
Merge the true and false vectors to form the destination vector, using
the selection vector to choose individual pixels from either input vector.
.le
.ls CALL fcn.reg, args, nargs
Call an intrinsic function with a list of arguments.  Each argument is
stored in a separate register.
.le
.ls CHT a.reg, dest.reg, newtype)
Change the datatype of an operand.
.le
.ls NEGATE a.reg, dest.reg
Vector or scalar negation.
.le
.ls ADD a.reg, b.reg, dest.reg
Vector or scalar addition.
.le
.ls SUB a.reg, b.reg, dest.reg
Vector or scalar subtraction.
.le
.ls MUL a.reg, b.reg, dest.reg
Vector or scalar multiplication.
.le
.ls DIV a.reg, b.reg, dest.reg
Vector or scalar division.
.le
.ls POW a.reg, pow.reg, dest.reg
Raise vector A to an integer or real power.
.le
.ls NOT a.reg, dest.reg
A 1 is output if A[i] is 0, else 0 is output.
.le
.ls AND a.reg, b.reg, dest.reg
A 1 is output if pixel A[i] and B[i] are both nonzero, else 0 is output.
.le
.ls OR a.reg, b.reg, dest.reg
A 1 is output if either pixel A[i] or B[i] is nonzero, else 0 is output.
.le
.ls LT a.reg, b.reg, dest.reg
A 1 is output if pixel A[i] is less than pixel B[i], else 0 is output.
.le
.ls GT a.reg, b.reg, dest.reg
A 1 is output if pixel A[i] is greater than pixel B[i], else 0 is output.
.le
.ls LE a.reg, b.reg, dest.reg
A 1 is output if pixel A[i] is less than or equal to pixel B[i],
else 0 is output.
.le
.ls GE a.reg, b.reg, dest.reg
A 1 is output if pixel A[i] is greater than or equal to pixel B[i],
else 0 is output.
.le
.ls EQ a.reg, b.reg, dest.reg
A 1 is output if pixel A[i] is equal to pixel B[i], else 0 is output.
.le
.ls NE a.reg, b.reg, dest.reg
A 1 is output if pixel A[i] is not equal to pixel B[i], else 0 is output.
.le
.le

.nh 3
Parser Actions

    The compile time actions of the parser include the opening of input and
output imagefiles, register allocation, evaluation of compile time constant
expressions, and metacode generation.  Any register allocation etc., required
to equalize the datatypes of the two operands of a binary operator is carried
out at compile time to avoid the need for type coercion (and dynamic memory
allocation) in the runtime instructions.  The instructions are always presented
with operands of like datatype.  The only exception is the argument list in
a function call, in which case the parser defers any decisions about datatypes
to the runtime code.

The internal parser stack is an array of operand structures each of which has
the format shown below.  The parser must keep track of the datatype and length
of each operand, and flag whether the operand is a compile time constant or
a variable, i.e., an operand whose value depends on the loop count (line number
within an image).  An expression involving an image operand is a compile time
constant expression if and only if the referenced image section consists of
only a single line.  If both operands to a binary operator are constants then
the parser can directly compute the value of the resultant operand without
generating any metacode.  In effect, invariant expressions are moved outside
the inner loop.  Image descriptors or registers used to evaluate compile time
constant expressions are freed immediately after use.

Note that removal of compile time constant expressions by inspection of
only two operands at a time does not detect all reducible constant expressions.
Furthermore, there is no provision for simplifying complex boolean expressions.
The final version of the image calculator may need to build a parse tree
and employ more sophisticated optimization techniques than those used here.


.ks
.nf
	struct operand {
		int	o_constant	# constant valued
		union {
		int	o_register	# associated register
		int	o_valb		# boolean value (stored as int)
		char	*o_valc		# string value
		int	o_vals		# short value (stored as int)
		int	o_vali		# int value
		long	o_vall		# long value
		real	o_valr		# real value
		double	o_vald		# double value
		complex	o_valx		# complex value
		} o_cv			# constant value
	}
.fi
.ke


The major parser actions may be grouped into the following classes:


.ks
.nf
	store			open output image or image section
	load			open input image or image section
	putconst		put a constant in a register
	unop			unary operator
	binop			binary operator
	quest			conditional expression
	call			function call
	addarg			add an argument to an argument list
	startarglist		begin a new argument list
.fi
.ke


These shall be implemented as the following procedures (yyval is the
output operand):


.ks
.nf
		imc_store (image, expr, yyval)
		 imc_load (image, yyval)
	     imc_putconst (const, yyval)
		 imc_unop (opcode, expr, yyval)
		imc_binop (opcode, expr_a, expr_b, yyval)
	       imc_boolop (opcode, expr_a, expr_b, yyval)
		imc_quest (bool_expr, true_expr, false_expr, yyval)
		 imc_call (function, arglist, yyval)
	       imc_addarg (arglist, expr, yyval)
	 imc_startarglist (expr, yyval)
.fi
.ke

.nh
Semicode for the Parser Actions

    The image calculator maintains an image descriptor for each image operand.
The imcalc image descriptor maintains the following information for each image:


.ks
.nf
	struct image {
		pointer	im		# pointer to real IMIO descriptor
		pointer	buf		# last buffer returned
		int	dtype		# pixel datatype
		int	linelen		# line length
		int	ateof		# have reached EOF on image
		long	v[IM_MAXDIM]	# line pointer into image
	}
.fi
.ke


Space is statically allocated for up to 50 image descriptors.  Note that
multiple sections may be open on the same image, hence there may be more
image descriptors than open files.


.tp 8
.nf
# IMC_STORE -- Open the output image or image section.  Determining the
# dimensions and header information of the new image for an arbitrary
# input expressions is quite difficult and we do not attempt to solve
# the problem properly in the prototype calculator.

procedure imc_store (image, expr, yyval)

begin
	allocate imcalc image descriptor

	if (not writing into a section of an existing image) {
	    # Determining which input image header to copy 
	    # for the output image is a nontrivial problem
	    # since the input expression may be anything.

	    map image as a new copy of first input image
		encountered by the lexical analyzer,
		i.e., the leftmost input image in the
		expression on the right hand side
	} else
	    map image section for read_write access

	compile OP_STORE
	yyval = expr
end
.fi


.tp 8
.nf
# IMC_LOAD -- Open an input image or image section.  If only one line
# in image, read line, close image, and return a constant operand.
# Otherwise allocate a register, compile the load instruction, and
# return a nonconstant token referencing the register.

procedure imc_load (image, yyval)

begin
	allocate imcalc image descriptor
	map image or image section for reading

	allocate a register 
	yyval.op_register = register

	if (only one line in section) {
	    read line into register
	    close image
	    free image descriptor
	    yyval.op_constant = yes
	} else
	    compile OP_LOAD
end
.fi


.tp 6
.nf
# IMC_UNOP -- Unary operator.

procedure imc_unop (opcode, expr, yyval)

begin
	allocate a register
	yyval.op_register = register

	if (expr.op_constant == yes) {
	    switch (opcode) {
	    case OP_MINUS:
		yyval = -expr
	    case OP_NOT:
		yyval = !expr
	    }
	    yyval.op_constant = yes
	    return register associated with expr
	} else
	    compile instruction
end
.fi


.tp 6
.nf
# IMC_BINOP -- Binary operator.

procedure imc_binop (opcode, a, b, yyval)

begin
	allocate a register for yyval

	# Set up the output operand.
	yyval.op_register = register
	yyval.op_datatype = max (a.op_datatype, b.op_datatype)
	if (a.op_constant == yes && b.op_constant == yes)
	    yyval.op_constant = yes

	# Coerce the two input operands to the same datatype.
	call imc_coerce (a, a_op, yyval.op_datatype)
	call imc_coerce (b, b_op, yyval.op_datatype)

	if (yyval.op_constant == yes) {
	    # Perform the operation; free all operands except yyval.
	    perform the operation
	    free a_op, b_op
	} else {
	    # Compile code to erform the operation.
	    compile binary operation a_op op b_op -> yyval
	}
end
.fi


.tp 6
.nf
# IMC_QUEST -- Conditional expression.

procedure imc_quest (sel, t, f, yyval)

begin
	allocate a register for yyval

	# Set up the output operand.
	yyval = register
	yyval.op_datatype = max (t.op_datatype, f.op_datatype)
	if (t.op_constant == yes && f.op_constant == yes)
	    yyval.op_constant = yes

	# Coerce the selector to type integer if necessary.
	call imc_coerce (sel, sel_op, int)

	# Coerce the two input operands to the same datatype, if
	# necessary, before performing the operation.

	call imc_coerce (t, t_op, yyval.op_datatype)
	call imc_coerce (f, f_op, yyval.op_datatype)

	if (yyval.op_constant == yes) {
	    perform the operation
	    free sel_op, t_op, f_op
	} else
	    compile OP_SELECT for sel_op, t_op, f_op -> yyval
end
.fi


.tp 8
.nf
# IMC_COERCE -- Coerce the datatype of an operand, if necessary.  If the
# datatype is already correct do nothing.  If the type must be coerced
# but the input operand is a constant, perform the coercion directly,
# otherwise generate metacode to effect the conversion at runtime.

procedure imc_coerce (op, new_op, new_datatype)

begin
	if (op.op_datatype != new_datatype) {
	    allocate a register
	    new_op = register
	    new_op.op_datatype = new_datatype

	    if (op.op_constant == yes) {
		coerce operand to new type
		free op
	    } else
		compile OP_CHT

	} else
	    new_op = op
end
.fi


.tp 6
.nf
# IMC_CALL -- Call an intrinsic function.

procedure imc_call (function, arglist, yyval)

begin
	convert function name into function code by keyword
	    table search

	allocate register
	yyval = register

	if (all args are constants) {
	    yyval = function (arglist, nargs)
	    free the args
	} else
	    compile OP_CALL to call function at runtime
end
.fi


Due to the way expressions are evaluated when parsing an argument list
(including the possible nesting of procedure calls), the register indices
generally will not form a contiguous set.  Hence it is necessary to 
represent an argument list as an array of register indices, which we shall
call a "call frame".  For simplicity we statically allocate a fixed number
of call frames, each of which has a fixed maximum number of arguments.
Since function calls may be nested we might have to start building a new
argument list before a previous one has been completed.  The data structures
needed to describe argument lists are therefore as follows:


.ks
.nf
	short	arg[MAX_ARGS,MAX_CALLS]	# storage for register lists
	short	nargs[MAX_CALLS]	# number of arguments
	int	callno			# call frame number
.fi
.ke


.tp 6
.nf
# IMC_STARTARGLIST -- Start compiling a new argument list.  If the operand
# struct pointer EXPR is null (null argument list) return a null YYVAL.

procedure imc_startarglist (expr, yyval))

begin
	if (expr == NULL)
	    callno = 0
	else {
	    callno += 1
	    if (callno > MAX_CALLS)
		error: "too many function calls"

	    nargs[callno] = 1
	    arg[1,callno] = expr.op_register
	}

	yyval.op_value = callno
end
.fi


.tp 6
.nf
# IMC_ADDARG -- Add an argument to the argument list currently being
# compiled.

procedure imc_addarg (arglist, expr, yyval)

begin
	callno = arglist.op_value

	argno = nargs[callno]++
	if (argno > MAX_ARGS)
	    error: "function call has too many arguments"

	arg[argno,callno] = expr.op_register
	yyval = arglist
end
.fi
