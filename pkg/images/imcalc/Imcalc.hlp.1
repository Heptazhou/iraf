.help imcalc Feb84 "Image Calculator"
.sp 
.ce
\fBDetailed Design of the Prototype Image Calculator\fR
.ce
Doug Tody
.ce
February 1984

.nh
Introduction

    The image calculator provides a powerful and efficient capability
for evaluating a very general class of expressions involving images.
Though the input language of the image calculator recognizes only the
assignment statement, a variety of assignment operators are provided,
and the expression on the right hand side may be arbitrarily complex.
The operands to an expression may be simple scalars or images, image sections,
or image projections of arbitrary dimension, size, and datatype.  Mixed mode
expressions are permitted, i.e., operands of different dimensions, sizes,
and datatypes may be mixed within a single expression.  A large selection
of pointwise intrinsic functions and projection functions are provided.
General transposition of any two axes of an input image or image type
subexpression is provided as an intrinsic function.

    Applications of the image calculator include general image arithmetic,
image analysis (statistics), averaging, filtering by convolution, subraster
extraction, transposition, reflection, mosaicing, editing, subsampling;
image combination using masks, pointwise functions, or projection functions;
and various conditional operations upon images.  All computations on image
data are fully vectorized and pixel i/o is minimized globally over the
expression, hence operation of the image calculator is extremely efficient
for whole image operations on large images.  There is no builtin limit
on the size of an image.  The memory requirements of the calculator are
modest; the calculator will dynamically adjust itself at runtime to work
within the memory limitations of the host machine.

    The image calculator described herein is implemented as a stand alone
program which compiles and executes high level statements read from the
standard input.  In the future, the parsing of image expressions will be moved
into the command language, making it easier to use image expressions
within CL loops, as arguments to procedures, and so on.  The present image
calculator provides the raw capability of image expressions without requiring
extensive modifications to the CL (which would lead to additional delays).
Furthermore, implementation of a prototype calculator will help define the
required modifications to the CL.  In the final implementation, the parser
in the image calculator program will be replaced by an assembler, with the
CL doing the parsing and passing assembler like instructions to the calculator.
The calculator will be much the same as it is now, but by virtue of being
integrated into the CL will be hidden from the user.

.nh
Requirements

    The image calculator is targeted at two major applications: general end
user interactive image processing, and bulk image reductions.  To be useful
for general interactive image processing, the calculator must provide a
concise notation for expressing a large class of common image operations.
To be useful for bulk image reductions, the calculator must be efficient.

.ls 4
.ls [1]
The calculator shall be able to process arbitrarily complex algebraic
expressions, possibly spanning multiple lines of input.
.le
.ls [2]
The calculator shall recognize the following as the operands to an expression:
images, image sections, scalar constants, or functions of any of the above.
A range of intrinsic functions shall be provided.
.le
.ls [3]
All of the standard arithmetic and boolean operators shall be supported.  
There shall be a "use and replace" assignment operator for each
arithmetic operator and for the \fIand\fR and \fIor\fR boolean operators,
permitting operations on sections of existing images.  The conditional
expression shall be supported, permitting selection of one of two possible
output pixel values depending on the value of the corresponding input pixel
in a boolean image expression.
.le
.ls [4]
It shall be possible for multiple input operands in an expression to refer
to the same image, and for the same image to be referenced both as an
input operand and as the output operand.  If an image is multiply referenced
in an expression, the imagefile shall be physically opened only once.
.le
.ls [5]
If a new output image is being written, and the new image would overwrite
an existing image of the same name, and file clobber is disabled, and the
statement is an ordinary assignment, it is an error.  It shall be possible
to silently overwrite an existing image using the ":=" assignment operator.
.le
.ls [6]
There shall be no fixed limit on the size of an image which can be processed,
or upon the size of any of the axes of an image.  In particular, it shall be
possible to process very large one-dimensional images without requiring
that each image (i.e., image line) be resident in memory.
.le
.ls [7]
The calculator shall be usable on any machine with sufficient per-process
memory for the text of the program, plus a modest amount of space for data.
It shall be possible to evaluate complex expressions involving very large
images on machines with only 1-2 Mb of physical memory and no virtual memory
facilities.  The calculator shall dynamically size its data buffers to
make maximal use of the memory available on a particular machine.
.le
.ls [8]
The calculator must be efficient when performing whole image operations on
the large digital images common in astronomy today.  As far as possible,
all computations on the image data shall be performed by calls to the VOPS
vector primitives.  As far as possible, expressions shall be evaluated without
writing intermediate images to disk, minimizing i/o globally over the
expression.
.le
.le

.nh
Specifications
.nh 2
Operands

    The operands in an expression may be scalars, images or image sections
of up to seven dimensions, or functions of any of the above.  An image section
may be used anywhere an image may be used.  All identifiers or quoted strings
appearing in expressions are assumed to be the names of images or image
sections.  All numbers are assumed to be scalars (rather than numbered files).

    If an expression contains a scalar and an image, the result is the same
dimensionality as the image.  If an expression contains two images,
the number of pixels per line in the result is the minimum line length
of the two images.  If an expression contains two images differing in the
number of dimensions, the dimension of the result is the maximum dimension
of the two images (the lesser dimensioned image is "rewound" as many
times as necessary to compute the result).  All operators commute.

    For example, consider the statement "a = b * c".  If B.ndim=2 and
C.ndim=1, A will be a two dimensional image, wherein the number of pixels
per line is min(b.len[1],c.len[1]), the number of lines is b.len[2],
and each line of A is computed by multiplying the corresponding line
of image B by the vector C.  If instead C were a two dimensional image
with one pixel per line (i.e, a transposed vector), the resultant image
A would be computed by multiplying each column of B by the vector C.

.nh 2
Datatypes

    The image calculator performs all internal calculations in one of four
datatypes: short, long, real, or double.
The disk datatype of an image may be any of the seven datatypes currently
supported by IMIO, i.e., short, unsigned short, int, long, real, double,
and complex.  Precision is lost when evaluating expressions involving images
of type long or double.  If an input image is of type complex, the real
part is used and the imaginary part is discarded.
All datatypes except short are promoted to type real upon input.
Mixed mode expressions produce a real result.  The datatype of an output
image is the datatype of the expression on the right hand side, unless
the left hand side is a section of an existing image.

.nh 2
Lexical Form

    The lexical form of an identifier, number or quoted string is identical
to that used in the CL and SPP languages.  An image section is anything
following the left brace until the closing brace is encountered.  The
assignment operators are equivalent to those used in the CL, with the addition
of ":=", which permits the output image to silently overwrite an existing
image.  The boolean operators produce a short integer result.

.nf
	IDENT		[a-zA-Z][a-zA-Z0-9_.$]*
	CONST		number or quoted string
	SECTION		'[' (anything) ']'

	UNOP		"-"  | "!"
	EXPON		"**"
	BINOP		"+"  | "-"  | "*"  | "/" 
	RELOP		"==" | "<"  | ">"  | "<=" | ">=" | "!="
	ASGNOP		"="  | ":=" | "+=" | "-=" | "*=" | "/=" | "**=" |
			"|=" | "&="
.fi

.nh 2
Grammar

    The parser uses the Yacc grammar shown below.  The parser is implemented
with a modified version of Yacc producing SPP output code.


.nf
	stmt	:	operand ASGNOP expr eost
		;

	expr	:	operand
		|	IDENT '(' arglist ')'
		|	expr BINOP opnl expr
		|	expr EXPON expr
		|	expr RELOP expr
		|	UNOP expr
		|	expr '?' expr ':' opnl expr
		|	'(' expr ')'
		;

	arglist	:	/* EMPTY */
		|	arglist ',' opnl expr
		;

	operand	:	IDENT
		|	IDENT SECTION
		|	CONST
		|	CONST SECTION
		;

	opnl	:	/* EMPTY */
		|	opnl '\n'
		;

	eost	:	';'
		|	'\n'
		;
.fi

.nh 2
Intrinsic Functions

    The image valued intrinsic functions take one or more scalars or
images as input and produce a scalar or image result.  These are simple
pointwise operators, i.e., the value of an output pixel depends only on
the values of the corresponding pixels in each of the input images.

.ks
.nf
	atan2	cos	exp	log	log10	sin	tan
	abs	sqrt	mod	int	real	floor	ceil
.fi
.ke

For example,

	a := floor (log(a-44.2), 1E-3)

would produce an image A wherein each output pixel is the natural log of 
the corresponding input pixel minus 44.2, or the value 0.001, whichever
is larger.  The assignment operator ":=" tells the image calculator that
it is permissible for the output image to overwrite an existing image.
If file clobber is enabled, ":=" is equivalent to an ordinary assignment.

.nh 2
Projections

    The vector valued intrinsic functions return a vector result wherein
the value of each output pixel is computed over each line of the argument.
If the argument is a scalar or a vector, the function returns a scalar.

.nf
	min	max	sum	mean	median	len
.fi

For example, consider the expression below, which subtracts a column vector
from a two dimensional section of image B:

	a = b[1:100,*] - median (b[101:128,*])

Each line of the output image A will be 100 pixels in length and will be 
computed by subtracting the median of the last 28 pixels on each line of
the input image from the value of each of the first 100 pixels on the line.

.nh
Implementation Strategies

    Input to the image calculator consists of a stream of assignment
statements on the standard input (or a single statement as a string
parameter).  Each statement is interpreted and executed independently
of the preceeding statement.  The action of the image calculator in
processing a statement is as follows:
.ls
.ls [1] \fBCompilation\fR

The statement is first "compiled" into a stream of high level imcalc
instructions.  The inner language of imcalc is a conventional reverse
polish, stack oriented language, similar to that used in the CL.
In the future, the CL parser will take over this function,
and the imcalc compiler will be replaced by an assembler.

The inner language is best explained by showing the translation of a
few sample statements:

.ks
.nf
	a = (b + c) / 2

		put	a
		get	b
		get	c
		add
		push	2
		div
.fi
.ke


.ks
.nf
	a = b + min (c, d)

		put	a
		get	c
		get	d
		call	min, 2
		get	b
		add
.fi
.ke


.ks
.nf
	a = (b > 0) ? c : d

		put	a
		get	b
		push	0
		gt
		get	c
		get	d
		qvec
.fi
.ke


.ks
.nf
	a += b

		put	a
		get	a
		get	b
		add
.fi
.ke

Each operand is described by a typecode and a value.  The typecodes are
image, for image operands, and int and real, for scalar operands.
The operand values are the image header pointer in the case of an image,
or a numeric value in the case of a scalar.

Whenever a GET or PUT opcode is compiled for an image type operand,
the associated image section string is added to a list.
There is only one PUT instruction per program, and it is always the first
instruction in the program.
.le

.ls [2] \fBInitialization\fR

If compilation is successful, the images
are opened in preparation for executing the program.  All images must be
open simultaneously, and the output image is written a line at a time
(more on this later).  Images may be multiply opened for reading on the
right hand side.  A different image descriptor is used for each instance
of an image which is multiply opened (so that different sections of the
same image may be opened), but the pixel storage file is only opened once.
Images are always opened with a single input buffer.

While opening the images, the program keeps track of the dimensions of
the operands, computing the dimension of the output image.  The image header
of the output image is set up accordingly at the end of the initialization
phase (unless output is to a section of an existing image).
.le

.ls [3] \fBExecution\fR

With compilation and initialization completed, the run time interpreter
is called to execute the compiled code.  The program is run once for
each line in the output image.  When the PUT instruction, which translates
into an IMPNLS or IMPNLR call to IMIO, returns EOF, execution is completed.

Each GET and PUT call reads or writes an image line, leaving a buffer pointer
and a pixel datatype code on the run time (operand) stack.  The operand
stack contains two types of objects: scalars and vectors, either of which
may be of datatype short or real.  Each arithmetic or boolean instruction
or function call pops one or more operands from the stack and pushes the
result on the stack.  Additional vector buffers are dynamically allocated
as necessary to hold the intermediate results.

If a GET call returns EOF during the execution of a program loop, the associated
image is "rewound" by resetting the loop vector to point to the first line
in the image, and the GET is repeated.  This feature is most commonly used 
n a binary operation where the operands are a multidimensional image and a
vector, in which case the vector image is rewound each time through the loop.
If one of the operands is a multidimensional (i.e., transposed) vector,
the vector operand reduces to a scalar each time through the loop, since the
loop is over image lines.

Boundary extension is permitted under control of CL level parameters
specifying the number of pixels of boundary extension permitted,
and the technique to be used to generate pixels lying beyond the boundary
of the image.  Boundary extension is automatically enabled whenever the
"shift" notation is used in an image section.
.le

.ls [4] \fBTermination\fR

When the end of the output image or image section is reached, the program
terminates, all images are closed, and all buffer space is returned.
.le
.le

.nh
Program Structure

    The image calculator is both a library routine (a subroutine) and a
program.  The program module (t_imcalc) contains all the CLIO calls.
The library routine (imcalc) is callable from any program.  Imcalc is
called with a file descriptor from which it can read commands, and a
few parameters specifying whether boundary extension is permitted, etc.
The command file may be a string buffer opened with stropen, if desired.


.ks
.nf
t_imcalc
	clgeti, clgets, etc.
	imcalc
		onerror
		compile
			get_token
				getline
				lexnum
			add_image
			compile_0
			compile_1
			compile_2
		initialize
			open_image
				immap
			get_registers
				malloc
		execute
			put_image_line
				pushop
			get_image_line
				pushop
			call_intrinsic
				find_keyword
				popop
				achtsr, achtrs, amod, asin, etc.
				pushop
			binop
				popop
				aadd, aaddk, asub, asubk, amul, etc.
				pushop
			unop
				popop
				aneg, anot, etc.
				pushop
		terminate
			close_image
				imunmap
			free_registers
				mfree
.fi
.ke


The structure of the imcalc subroutine reflects the four phases required
to process a command, described in the previous section.  In short, these
are compile, initialize, execute, and terminate.  The terminate procedure
is also posted to the IRAF main with ONERROR, to cleanup after an abort.
All image arithmetic is performed with the VOPS vector operators in the
execute phase.

.nh
Data Structures

    All strings are stored in a string buffer and referenced internally
with a pointer.  Examples of strings are image names, image sections,
and intrinsic function names.  Instructions are compiled into the program
space, an integer array.  Instructions are variable length.
The parser stack is an integer array.  Each token is represented on the
parser stack by an integer pointer into the token buffer, an array of
token structures.  The runtime operand stack is an array of operand
structures.

Pixel buffers are for the most part dynamically allocated and controlled
entirely by IMIO.  The exceptions are the buffers used to hold intermediate
results.  The calculator dynamically allocates a fixed number of "register"
buffers during the initialization phase for storage of intermediate results.
All register buffers are the same size, the size being the length of an
output image line of type real.  Register buffers are reused as control
flows through the program, and the same buffer may be used at various
times to store either short or real pixels.

To summarize the principal data structures used in imcalc:

.ks
.nf
	string buffer		storage for all strings
	program space		list of binary instructions and
				    operands (variable length)
	parser stack		array of token struct pointers
	token buffer		array of token structures
	operand stack		array of operand structures
	keyword table		names of intrinsic functions

	nimages			number of images in statement
	images			array of image descriptor structures
	line_length		length of output image line
	nregisters		number of register buffers
	register_list		list of ptrs to register buffers
.fi
.ke

All internal control buffers are implemented with fixed storage,
since the calculator need deal with only a single statement at a time.
Storage of image headers, file descriptors, pixel arrays, etc.
is dynamically allocated.  The maximum number of input images, registers,
depth of the parser stack, etc., is fixed at compile time.

The token structure is defined below.  The toktype field identifies the token,
i.e., IDENT, CONST, ASGNOP, etc.  The dtype field specifies whether a
numeric constant is an integer, real, or string.  The value field is a numeric
value for an integer or real constant, a string pointer for a string constant,
identifier, or section, and an integer code in cases where a token
represents a class of similar lexical items (i.e., the assignment operators).


.ks
.nf
struct token {
	int	t_toktype		# token type
	int	t_dtype			# numeric type
	union {
		int	v_i
		real	v_r
		char	*v_s
	} t_value			# token value
}
.fi
.ke


The operand structure describes objects on the operand stack, and is
passed in argument lists to subprocedures.  The optype field identifies
the operand as either a scalar or a vector.  The dtype field gives the
datatype of the pixel(s), and the value field contains the pixel value
in the case of a scalar, or a pointer to an array of pixels of type dtype
in the case of a vector operand.


.ks
.nf
struct operand {
	int	o_optype	# scalar or vector
	int	o_dtype		# datatype
	union {
		int	v_i	
		real	v_r
		pixel	*v_v
	} o_value		# value
}
.fi
.ke


The image descriptor contains all of the information the image calculator
needs to operate upon an image.  The IMIO image header is not referenced
directly to minimize knowledge of this structure within imcalc.
The image is "rewound" by setting all of the elements of the vector
i_nextline unity.  All the image calculator needs to know about the
dimensionality of an image is the length of an image line.


.ks
.nf
struct image {
	long	i_linelen		# length of image line
	long	i_nextline[IM_MAXDIM]	# coords of next line in image
	int	i_dtype			# pixel datatype
	char	*i_imname
	char	*i_imsection
	struct	imhdr *i_imhdr		# pointer to IMIO image header
} images[MAX_IMAGES]
.fi
.ke


Storage for the compiler and the executor is allocated separately,
i.e., under control of independent commons, with the only communication
between the two phases being the executable program.

.nh
Semicode


.nf
procedure t_imcalc

begin
	fetch nboundarypix, boundarytype parameters from CL

	if (command given as an argument) {
	    make a string buffer
	    read command into it
	    open string buffer as a file
	    call imcalc to execute commands from string buffer
	    close string buffer file
	    return string buffer memory
	} else
	    call imcalc to execute commands from standard input
end
.fi


.nf
procedure imcalc (in, nboundarypix, boundarytype)

begin
	initialize database: clear parser and operand stacks, clear program
	    space, clear image list and string buffer

	# Loop over input statements.  Compile and execute each statement
	# in the input stream.

	while (compile_statement (in) != EOF) {
	    open_images
	    execute
	    reinitialize database
	}
end
