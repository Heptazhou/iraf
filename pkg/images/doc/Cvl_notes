.helpsys display,dcontrol Jly83 "Image Display Routines"
.sh
Introduction

    The DISPLAY program shall be used to display images on the default
image display device.  The DCONTROL program (a better name would be nice)
shall be used to control the image display device, i.e., select frames,
adjust the mapping tables, etc.

The lifetime of these programs is not known at present, so it would be
unwise to put a lot of effort into creating programs which significantly
exceed the requirements given here.  We do not have time at present to
fully exploit the capabilities of any particular display, such as the
IIS.  Furthermore, we would like to use these programs to control the
primitive display device we will be experimenting with in the fall.

.sh
Requirements for the DISPLAY Program
.ls 4 (1)
The DISPLAY program shall be CL callable.
.le
.ls (2)
The function of DISPLAY shall be to map an image or image section
into the specified frame of the default image display device.
The following simple calling sequence shall suffice to display an image
or image section:

	display (image, frame)

where "image" is the name of an image or image section, and "frame" is
the frame to be used, numbered 1, 2, 3, etc.  For example, if "cube"
is a three dimensional image cube, the command

	display ("cube[*,-*,5]", 1)

would map the entire fifth band of the cube into frame number 1, with the
y-axis flipped (IMIO processes image sections transparently to DISPLAY).
Default transformations would be used to map image coordinates into
display coordinates, and image pixel values into display pixel values.
Similarly,

	display ("cube[1,*:8,10:20]", 1)

would map the y-z plane for which x=1 into frame 1, subsampling the
x-axis by 8 pixels, and displaying only the indicated range (z=10 to
z=20) of pixels in z.
.le
.ls (3)
The following options shall be available, under control of hidden
parameters with default values:
.ls
.ls o
Erase frame before displaying image.
.le
.ls o
Scale the x,y dimensions of the image to fit the physical frame of the
display device (autoscale in x,y).  The aspect ratio should be maintained
at unity, unless an option is added to permit independent scaling of
the two axes.
.le
.ls o
Do not autoscale in x,y, i.e., map the image 1 to 1 in x,y (into center
of window).
.le
.ls o
Enter explicit x,y scaling factors (magnification).  Map image into
center of frame using these fixed scaling ratios.
.le
.ls o
Enter Z1 and Z2, the range of intensities to be mapped into the
8 bits (or whatever) available on the physical device.
.le
.ls o
Use the values of Z1 and Z2 last used for the output frame.
.le
.ls o
Autoscale, using the minimum and maximum pixel values.
.le
.ls o
Autoscale, by computing a full or partial histogram for the image,
and automatically computing the values of Z1 and Z2 which straddle
the main peak of the histogram (if there is a single peak).
This requires development of a new algorithm.  I expect that this
will be the option most often used, if the algorithm works.
It may be desirable to subsample the image for the sake of efficiency.
.le
.ls o
Both logarithmic and linear grayscale transformations shall be
available.
.le
.le
.le
.ls (4)
When an image is displayed, a graphics device descriptor file shall be
written describing the transformations used to map the image into
the frame given as the second argument.
The descriptor file is subsequently read by the CL when the image display
cursor is read.  The format of this descriptor file is specified elsewhere.
.le
.ls (5)
The device independent part of the DISPLAY routine shall be written in
the SPP language.
.le
.ls (6)
The DISPLAY routine shall be divided into a device independent part
and a device dependent part.  The device dependent part shall consist
of a set of SPP callable primitives.  Though the primitives will
themselves necessarily be device dependent, the functions they provide
shall be device idependent, i.e., available on all forseeable image
display devices.  A function may be added which cannot actually be
implemented on all display devices, provided that the function is
noncritical, and can be included in the interface as a nop.
.le

.sh
Requirements for the DCONTROL Program
.ls (1)
The DCONTROL program shall be CL callable.
.le
.ls (2)
The function of the DCONTROL program shall be to interactively control
the default image display device.
.le
.ls (3)
The following functions shall be provided:
.ls
.ls o
Select frame to be displayed.
.le
.ls o
Erase graphics frame.
.le
.ls o
Erase image frame.
.le
.ls o
Adjust windowing.
.le
.ls o
Zoom and roam.
.le
.le
.le
.ls (4)
Any other functions you wish to add (blink, print pixel value, etc.).
We do not have time at present to fully exploit the capabilities of
specific displays, such as the IIS.
.le
.ls (5)
The device independent part of the DCONTROL routine shall be written in
the SPP language.
.le
.ls (6)
The DCONTROL routine shall be divided into a device independent part
and a device dependent part.  The device dependent part shall consist
of a set of SPP callable primitives.  Though the primitives will
themselves necessarily be device dependent, the functions they provide
shall be device idependent, i.e., available on all forseeable image
display devices.  A function may be added which cannot actually be
implemented on all display devices, provided that the function is
noncritical, and can be included in the interface as a nop.
.le

.sh
Specifications of the image display interface to IMIO/FIO

    An image frame buffer, for example one of the 8-bit by 512 square
image planes in an image display device, is a random access mass storage
device.  By interfacing such a device to FIO, the image plane can be
accessed as a binary file.  Going one step further, we can use the image
plane as the pixel storage file for an IMIO imagefile.

An imagefile consists of two files: the image header file, and the pixel
storage file.  While it makes sense to place the pixel storage file on
a special device, it is best to maintain the header file as a regular file.
In general, different header files are required to access different image
display devices, because the dimensions of an image frame may depend on
the device.  The following header files are defined for the IIS display:

	lib$iisim1, lib$iisim2, etc.

An IIS image plane is opened as an imagefile using the special mapping
routine IMDMAP.  IMDMAP is identical to IMMAP, except that it is illegal
to create a new image on a special device; the legal access modes are
READ_ONLY, READ_WRITE, and WRITE_ONLY.  The WRITE_ONLY access mode may
be used to command that the frame be erased before writing, if desired.
Both special and regular imagefiles are unmapped with IMUNMAP.

	imhdr_ptr = imdmap ("lib$iisim1", READ_WRITE, 0)

IMDMAP calls IMDOPEN, which opens the image frame as a binary file.
FIO requires a set of six z-routines to access a binary file (shown
below).  These should be easy to implement for any image display device.

.ks
.nf
	zopnim (image_plane, access_mode; channel/status)
	zclsim (channel)
	zardim (channel, buf, maxbytes, byte_offset)
	zawrim (channel, buf, nbytes, byte_offset)
	zawtim (channel; nbytes/status)
	zsttim (channel; long_status_value)
.fi
.ke

ZOPNIM is called to open one of the image planes, named "image1",
"image2", and so on.  I/O is done with ZARDIM, ZAWRIM, and ZAWTIM
(asynchronous blocked read, write, and wait).  IMIO assumes that
the first line of the image is at file offset 1 byte, the second
at offset 1025 (assuming 512 pixels per line), and so on.

The z-routines assume that image display pixels are of type short integer
(the current version of IMIO cannot deal with type UBYTE pixels).
If this is not the case, the z-routines must pack and unpack pixels,
possibly requiring the use of an internal buffer.

The ZSTTIM routine is called by FIO to get the status values shown in
the table below.  The block size may be given as 1 if the device is
randomly accessible, otherwise it will probably need to be the size of
a line (1024 bytes).  Note that FIO may read and write any integer number
of blocks in a single transfer (it depends on the size of the FIO buffer).

.nf
	  mnemonic	integer code		meaning

	FSTT_BLKSIZE	     1		device block size, bytes
	FSTT_FILSIZE	     2		file size, bytes (incl. hdr)
	FSTT_OPTBUFSIZE	     3		optimum buffer size
.fi

.sh
Specifications of the Graphics Descriptor File

    The DISPLAY program interfaces to GIO via the graphics descriptor
file.  The GDF for the image display device, only one of which may be
in use at a time, is the text file "uparm$stdimage.gd".  The GDF
consists of a set of records, each of which describes a single graphics
window.  When a window is modified, a new record is added to the end
of the file, overriding any earlier records for that particular window
of the graphics device.

A GDF record has the following form:

.ks
.nf
	$w image_section
	mx1 mx2 my1 my2 0
	px1 px2 py1 py2 0
	ux1 ux2 uy1 uy2 0
	z1 z2 zflags
.fi
.ke

where the $ marks the start of the record and is required, and
where "image_section" is the imagefile name (if any), followed by
the image section (if any), as obtained from IMSTATS.  The MX,
PX, and UX lines give the coordinates of the plot window in
metacode coordinates (normalized to the range 0-32767), pixel
coordinates, and user coordinates.  The final line defines the
grayscale transformation.  ZFLAGS should be 0 if the transformation
is linear, 1 if a log transformation is used.

The W or "window" field encodes both the screen number and the
window number, in the form:

	w = screen * 100 + window

Since DISPLAY uses only one window per screen (image plane), W should
have the values 101, 201, etc. for successive screens.

Metacode coordinates range from 0 to 32767, providing up to 32768
resolution units in each axis.  The metacode coordinates of the
actual screen area filled by the displayed image must be given
(physical cursor coordinates, by the way, should also be given in
metacode units for device independence reasons).

For DISPLAY, the PX and UX lines should be identical, and should
give the range of pixel coordinates for the window, i.e.,
PX1=1, PX2=IM_LEN(im,1), etc.

A sample record for a 1 to 1 mapping of the section "cube[*,-*,5]"
is shown below.  The imagefile pathname may be obtained from the
image header (field "IM_HDRFILE").  The image section may be obtained
by fetching the parameter IM_SECTION using IMSTATS.

.ks
.nf
	$101 /usr/tmp/cube[1:64:1,64:1:1,5:5:1]
	14336 18432 14336 18432 0
	1. 64. 1. 64. 0
	1. 64. 1. 64. 0
	436. 4.292E5 0
.fi
.ke
.endhelp

.help cvl Jun85 "Image Display Load Program"
.sh
Specifications for the CVL Program

    The CVL program has the following parameters:

.nf
                      Display image  image =
                      Display frame  frame = 1
                        Erase frame (erase = yes)
		   Erase the border (border_erase = no)
	 Display frame being loaded (select_frame = yes)
  Scale image to fit display window (fill = yes)
  Display range of gray near median (zscale = yes)
     Contrast adjustment for zscale (contrast = 0.25)
 Display full image intensity range (zrange = yes)
	     Number of sample lines (nsample_lines = 5)
            Display window x center (xcenter = 0.5)
            Display window y center (ycenter = 0.5)
              Display window x size (xsize = 1.)
              Display window y size (ysize = 1.)
     Display window x magnification (xmag = 1.)
     Display window y magnification (ymag = 1.)
       Minimum greylevel to display (z1 = 0.)
       Maximum greylevel to display (z2 = ..)
Greylevel mapping (linear|log|none) (ztrans = linear)
                                    (mode = ql)
.fi

    The automatic parameters are the image filename "image" to be displayed
and the display frame.  The simplest calling sequence is then

	cvl image frame

    The display options are controlled by a set of hidden parameters
which can be adjusted by the user.  The following describes the effect
of these options.

.ls 4 erase
The "erase" parameter causes the display frame to be
erased prior to displaying an image if it is set, otherwise, the image
overwrites the current contents of the display.
.le

.ls border_erase
This parameter causes the border of an image that does not fill the
physical display to be set to zero (erased).
.le

.ls select_frame
This parameter determines whether or not the frame being loaded is to
be made visible (selected).  If not, the frame is loaded while the image
display presents whatever frame(s) were selected by the user before the
image load command was given.
.le

.ls xcenter, ycenter, xsize, ysize
Apart from the "erase" parameters the CVL program will only affect
the contents of the display window.  The display window is defined
by the center coordinates "xcenter" and "ycenter" and the window sizes
"xsize" and "ysize".  Normally, these parameters will describe the
entire frame.
.le

.ls fill, xmag, ymag
The boolean "fill" parameter determines how the image fills the
display window.
If the fill option is set (the default) then the image will be expanded
or contracted by equal factors in both
dimensions to best fill the display window.
The dimension scaling factors will be stored in the parameters
"xmag" and "ymag".
If the fill option is not set then the image will be displayed with
the specified magnification factors "xmag" and "ymag" and the image
center will be centered in the window.  The
magnification factors are signed such that if the magnification is
positive then the image is expanded by the given factor and
if the value is negative then the image will be
reduced.  For example, "xmag = 2" will expand the
image to two display pixels per image pixel along the horizontal axis and 
"ymag = -2" will display every other pixel in the vertical axis.
Note that "ymag = -2" is equivalent to "ymag = .5" and either may be used.

The expansion or contraction will be by bilinear interpolation.  The
alternative of pixel sampling for contracting an image is available by
specifying the sampling interval in the image description;

	cvl image[*:2,*:2] 1

Image expansion by pixel replication is available in some display devices,
like the IIS, as a zoom feature.
.le

.ls ztrans
This parameter sets an intensity mapping function.
The functions are linear (the default), logrithmic, and none.
If none is selected, then none of the z1,z2/zscale/zrange options
discussed below are relevant.
.le

.ls z1,z2
The mimimum and maximum input intensity values to be mapped.
The type of mapping is determined by "ztrans".  z1/z2 are determined
automatically if either zscale or zrange is invoked; otherwise, the
user should set them.
.le

.ls zscale
If this parameter is set, it has precedence over the range and 
z1/z2 parameters.  "zscale" sets the operational mode to "auto-scaling".
The minimum and maximum intensities to be displayed (z1/z2) are
determined from the image by sampling a number of image lines
(nsample_lines), and fitting a straight line to the intensity
distribution.  Deviant pixels are rejected, a final line determined,
the line slope divided by "contrast" and the minimum and maximum
intensity levels (z1/z2) then determined.
.le

.ls zrange
If this parameter is set, and zscale is not, then z1 and z2 are 
determined by finding the minimum and maximum values that appear in
nsample_lines of the image.
.le

.ls nsample_lines
Determines the number of lines involved in the sampling done when
either zscale or zrange is invoked.
.le

.sh
Examples

.ls 4 (1)
The minimum calling sequence to display an image is:

	cvl image 1

.le
.ls (2)
To display an image on the left half of the display after erasing the frame:

	cvl image 1 erase+ xcenter=.25

"xsize" is automatically adjusted to .5 .
.le
.ls (3)
To display an image without dimensional scaling:

	cvl image 1 fill- xmag=1. ymag=1.

.le
.ls (4)
To reset the default to always erase:

.nf
	display.erase=yes
.fi
.le
