# Copyright(c) 1986 Association of Universities for Research in Astronomy Inc.

# CV_BCHEB -- Procedure to evaluate all the non-zero Chebyshev functions for
# a set of points and given order.

procedure $tcv_bcheb (x, npts, order, k1, k2, basis)

PIXEL	x[npts]		# array of data points
int	npts		# number of points
int	order		# order of polynomial, order = 1, constant
PIXEL	k1, k2		# normalizing constants
PIXEL	basis[ARB]	# basis functions

int	k, bptr

begin
	bptr = 1
	do k = 1, order {

	    if (k == 1)
		$if (datatype == r)
	        call amovkr (1.0, basis, npts)
		$else
	        call amovkd (1.0d0, basis, npts)
		$endif
	    else if (k == 2)
		call alta$t (x, basis[bptr], npts, k1, k2)
	    else {
		call amul$t (basis[1+npts], basis[bptr-npts], basis[bptr],
				npts)
		$if (datatype == r)
		call amulkr (basis[bptr], 2.0, basis[bptr], npts)
		$else
		call amulkd (basis[bptr], 2.0d0, basis[bptr], npts)
		$endif
		call asub$t (basis[bptr], basis[bptr-2*npts], basis[bptr], npts)
	    }
		
	    bptr = bptr + npts
	}
end

# CV_BLEG -- Procedure to evaluate all the non zero Legendre function
# for a given order and set of points.

procedure $tcv_bleg (x, npts, order, k1, k2, basis)

PIXEL	x[npts]		# number of data points
int	npts		# number of points
int	order		# order of polynomial, 1 is a constant
PIXEL	k1, k2		# normalizing constants
PIXEL	basis[ARB]	# array of basis functions

int	k, bptr
PIXEL	ri, ri1, ri2

begin
	bptr = 1
	do k = 1, order {

	    if (k == 1)
		$if (datatype == r)
		call amovkr (1.0, basis, npts)
		$else
		call amovkd (1.0d0, basis, npts)
		$endif
	    else if (k == 2)
		call alta$t (x, basis[bptr], npts, k1, k2)
	    else {
		ri = k
		$if (datatype == r)
		ri1 = (2.0 * ri - 3.0) / (ri - 1.0)
		ri2 = - (ri - 2.0) / (ri - 1.0)
		$else
		ri1 = (2.0d0 * ri - 3.0d0) / (ri - 1.0d0)
		ri2 = - (ri - 2.0d0) / (ri - 1.0d0)
		$endif
		call amul$t (basis[1+npts], basis[bptr-npts], basis[bptr],
				npts)
		call awsu$t (basis[bptr], basis[bptr-2*npts],
			basis[bptr], npts, ri1, ri2)
	    }
			
	    bptr = bptr + npts
	}
end

# CV_BSPLINE1 -- Evaluate all the non-zero spline1 functions for a set
# of points.

procedure $tcv_bspline1 (x, npts, npieces, k1, k2, basis, left)

PIXEL	x[npts]		# set of data points
int	npts		# number of points
int	npieces		# number of polynomial pieces minus 1
PIXEL	k1, k2		# normalizing constants
PIXEL	basis[ARB]	# basis functions
int	left[ARB]	# indices of the appropriate spline functions

int	k

begin
	call alta$t (x, basis[1+npts], npts, k1, k2)
	call acht$ti (basis[1+npts], left, npts)
	call aminki (left, npieces, left, npts)

	do k = 1, npts {
	    basis[npts+k] = basis[npts+k] - left[k]
	    $if (datatype == r)
	    basis[k] = 1.0 - basis[npts+k]
	    $else
	    basis[k] = 1.0d0 - basis[npts+k]
	    $endif
	}
end

# CV_BSPLINE3 --  Procedure to evaluate all the non-zero basis functions
# for a cubic spline.

procedure $tcv_bspline3 (x, npts, npieces, k1, k2, basis, left)

PIXEL	x[npts]		# array of data points
int	npts		# number of data points
int	npieces		# number of polynomial pieces minus 1
PIXEL	k1, k2		# normalizing constants
PIXEL	basis[ARB]	# array of basis functions
int	left[ARB]	# array of indices for first non-zero spline

int	i
pointer	sp, sx, tx

begin

	# allocate space
	call smark (sp)

	$if (datatype == r)
	call salloc (sx, npts, TY_REAL)
	call salloc (tx, npts, TY_REAL)
	$else
	call salloc (sx, npts, TY_DOUBLE)
	call salloc (tx, npts, TY_DOUBLE)
	$endif

	# calculate the index of the first non-zero coeff
	call alta$t (x, Mem$t[sx], npts, k1, k2)
	call acht$ti (Mem$t[sx], left, npts)
	call aminki (left, npieces, left, npts)

	# normalize x to 0 to 1
	do i = 1, npts {
	    Mem$t[sx+i-1] = Mem$t[sx+i-1] - left[i]
	    $if (datatype == r)
	    Memr[tx+i-1] = 1.0 - Memr[sx+i-1]
	    $else
	    Memd[tx+i-1] = 1.0d0 - Memd[sx+i-1]
	    $endif
	}

	# calculate the basis function
	call apowk$t (Mem$t[tx], 3, basis, npts)
	do i = 1, npts {
	    $if (datatype == r)
	    basis[npts+i] = 1.0 + Mem$t[tx+i-1] * (3.0 + Mem$t[tx+i-1] * (3.0 -
		3.0 * Mem$t[tx+i-1]))
	    basis[2*npts+i] = 1.0 + Mem$t[sx+i-1] * (3.0 + Mem$t[sx+i-1] *
	        (3.0 - 3.0 * Mem$t[sx+i-1]))
	    $else
	    basis[npts+i] = 1.0d0 + Mem$t[tx+i-1] * (3.0d0 + Mem$t[tx+i-1] *
	        (3.0d0 - 3.0d0 * Mem$t[tx+i-1]))
	    basis[2*npts+i] = 1.0d0 + Mem$t[sx+i-1] * (3.0d0 + Mem$t[sx+i-1] *
	        (3.0d0 - 3.0d0 * Mem$t[sx+i-1]))
	    $endif
	}
	call apowk$t (Mem$t[sx], 3, basis[1+3*npts], npts)

	# release space
	call sfree (sp)
end
